<!DOCTYPE html>
<html class="gr__leafletjs_com">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Heart Disease Mortality Data Among US Adults (population age 35+)</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" type="image/x-icon" href="https://leafletjs.com/examples/choropleth/docs/images/favicon.ico">
	<link rel="stylesheet" href="/static/leaflet.css" crossorigin="">
	<!-- integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" -->
	<script src="/static/leaflet.js" crossorigin=""></script>
	<!-- integrity="sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg==" -->
	<script src="/static/d3.js"></script>
	<script src='//js.zapjs.com/js/download.js'></script>
	<script src="static/setupFunctions.js"></script>
	<script src='https://cdnjs.cloudflare.com/ajax/libs/d3-tip/0.7.1/d3-tip.min.js'></script>


	<style>
		html,
		body {
			height: 100%;
			margin: 20;
		}

		.graph {
			margin-top: 8px
		}

		.grow_title {
			border-radius: 10px;
			height: 35px;
			width: 100%;
			float: left;
			position: relative;
			transition: height 0.5s;
			-webkit-transition: height 0.5s;
			text-align: center;
			overflow: hidden;
		}

		.grow_title:hover {
			height: 60px;
		}

		.grow_map_info {
			border-radius: 10px;
			height: 30px;
			width: 50%;
			float: left;
			position: left;
			transition: height 0.5s;
			-webkit-transition: height 0.5s;
			overflow: hidden;
		}

		.grow_map_info:hover {
			height: 155px;
		}
	</style>

	<style type="text/css">
		/* copied from lab 6 - Dennis */
		#tooltip {
			position: absolute;
			width: 200px;
			height: auto;
			padding: 10px;
			background-color: white;
			-webkit-border-radius: 10px;
			-moz-border-radius: 10px;
			border-radius: 10px;
			-webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			-moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			pointer-events: none;
		}

		#tooltip.hidden {
			display: none;
		}

		#tooltip p {
			margin: 0;
			font-family: sans-serif;
			font-size: 16px;
			line-height: 20px;
		}
	</style>



	<style type="text/css">
		/* copied from Dennis above - Jon */
		#tooltip2 {
			position: absolute;
			width: 200px;
			height: auto;
			padding: 10px;
			background-color: white;
			-webkit-border-radius: 10px;
			-moz-border-radius: 10px;
			border-radius: 10px;
			-webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			-moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			pointer-events: none;
		}

		#tooltip2.hidden {
			display: none;
		}

		#tooltip2 p {
			margin: 0;
			font-family: sans-serif;
			font-size: 16px;
			line-height: 20px;
		}
	</style>

	<style>#map { width: 100%; height: 50%}
.info { padding: 6px 8px; font: 14px/16px Arial, Helvetica, sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; } .info h4 { margin: 0 0 5px; color: #777; }
.legend { text-align: left; line-height: 18px; color: #555; } .legend i { width: 18px; height: 18px; float: left; margin-right: 2px; opacity: 0.7; } .queue {padding: 6px 8px; font: 14px/16px Arial, Helvetica, sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px;}
</style>
	<script src="chrome-extension://mooikfkahbdckldjjndioackbalphokd/assets/prompt.js"></script>

</head>

<body data-gr-c-s-loaded="true">
	<!-- ########################################################################################################################### -->
	<!-- ########################################################################################################################### -->
	<!-- #################################### DIVS ############################################################################## -->
	<!-- ########################################################################################################################### -->
	<div style="width:100%; ">
		<div class="grow_title">
			<h1 style="padding:0px; margin:0px">US Heart Disease Mortality rate</h1>
			<h5 style="padding:0px; margin:0px">Data is age-adjusted, spatially smoothed, and averaged over 3 years. Data is seperated by 5 race classes and 2 gender classes</h5>
		</div>
	</div>
	<!-- ##################################################### MAP Functionality div ############################################################################ -->
	<div class="grow_map_info" style="color:grey; font-size:13px; padding:5px; margin:0px">
		<h5>Hover over to learn about map functionality</h5>
		<!-- <p>Hover over to learn about map functionality</p> -->
		<li>Zooming in/out on the map will alternate between county or state layer, depending on the zoom level</li>
		<li>Hovering over state highlights the corresponding mark in scatterplot, also providing information in top right of map</li>
		<li>Hovering over county highlights the corresponding mark in bar chart, also providing information in top right of map</li>
		<li>Single click on state adds state to queue for further analysis, max states in queue is 4</li>
		<li>If there is more than one state in the queue, clicking on a state that is already in the queue will remove that state from the queue</li>
		<li>Double click on state zooms to state's bounds and switches to county layer</li>
		<li>Double click on county zooms out to state layer</li>
	</div>
	<!-- ##################################################### MAP ############################################################################ -->
	<div id="map" class="leaflet-container leaflet-touch leaflet-fade-anim leaflet-grab leaflet-touch-drag leaflet-touch-zoom" tabindex="0" style="position: relative;"></div>
	<!-- #################################### BOTTOM OF PAGE ############################################################################## -->
	<div id="graph_selector" style="color:grey; font-size:13px; padding:5px; margin:0px">
		<label onchange="graph_selection_change()"><input type="radio" name="radio_graph_select" value="county_bar_chart" checked>County mortality rate bar chart</label>
		&nbsp;&nbsp;&nbsp;&nbsp;
		<label onchange="graph_selection_change()"><input type="radio" name="radio_graph_select" value="density_vs_mort_rate_scatter">Density vs Mortality rate scatterplot</label>
		&nbsp;&nbsp;&nbsp;&nbsp;
		<label onchange="graph_selection_change()"><input type="radio" name="radio_graph_select" value="state_comp_bar_chart">Grouped bar chart</label>
	</div>
	<!-- #################################### radio buttons below map ################################################################### -->
	<div id="countyMortRateByState" class="graph">
		<script src="/static/countyMortRateByStateBarChart.js"></script>
	</div>
	<div id="stateMortRateByDensity" class="graph">
		<script src="/static/stateMortRateByDensityScatter.js"></script>
	</div>
	<!-- #################################### bottomest? of page ################################################################### -->
	<!-- stolen from Dennis - Jon -->
	<div id="tooltip2" class="hidden">
		<p><strong><span id="tooltip2Label">Important Label Heading</span></strong></p>
		<p><span id="value2">100</span></p>
	</div>
	<div id="groupedBarChartButtons"><button type="button" id="selectOverall">Overall</button><button type="button" id="selectGender">Gender</button><button type="button" id="selectRace">Race</button>
		<div id="jonsgraph" class="graph">
		</div>
	</div>
	<!-- ########################################################################################################################### -->
	<!-- ########################################################################################################################### -->
	<!-- #################################### SCRIPTS ############################################################################## -->
	<!-- ########################################################################################################################### -->
	<!-- source: https://leafletjs.com/examples/choropleth/ -->
	<!-- MAP js files  -->
	<script type="text/javascript" src="/static/us_states_boundary.js"></script>
	<script type="text/javascript" src="/static/data_as_json.js"></script>
	<script type="text/javascript" src="/static/us_county_boundary.js"></script>
	<script type="text/javascript" src="/static/cache.js"></script>
	<!-- end MAP js files  -->

	<script type="text/javascript">
		// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //
		// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //
		// GLOBAL VARIABLES
		var json_data = heart_disease_data.data;
		var geojson;
		var geojson_county;

		var zoom_state_county_split = 5.0;
		var map_type_level = "state";
		var current_zoom = 4;
		// default values for race and gender
		var race = "Overall";
		var gender = "Overall";
		// values used to store the values in the dropdowns for multiple criteria view
		var g1 = "Overall";
		var g2 = "Overall";
		var r1 = "Overall";
		var r2 = "Overall";
		var race_gender_inspector = "Single"
		// cache is used to store the already retrieved mort rate values for various criterias
		// avoiding having to search through the whole data, thus saving time
		//var cache = [];
		// Now try to get the data from cache instead of reading from large array
		var cache = cache_contents;
		// contains the list of states that have been clicked on, only two states are allowed to be selected at a timeout
		// selecting additional state will override previous selections
		var selection_list = [];
		// add MA to the queue
		selection_list.push("Massachusetts");
		var selection_count = selection_list.length;
		var selection_max = 4;
		// used to store the object which holds all information and functions to deal with the countyMortRateByStateBarChart - DS
		var countyMortRateByStateBarChart;
		// used to store the object which holds object dealing with stateMortRatebyDensityScatter - DS
		var stateMortRateByDensityScatter;

		var jons_graph_type = "overall";
		// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //
		// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //

		function return_avg(array) {
			// find the average from a list, return the average only if the length of the array is more than 0
			let sum, avg = 0;
			if (array.length != 0) {
				sum = array.reduce(function(a, b) {
					return a + b;
				});
				avg = sum / array.length;
				return Math.round(avg);
			} else {
				return "Insufficient information";
			}

		}


		// Return color HEX color based on d value
		// Single map mode has a sequential map style
		// Multiple map mode has a diverging map style
		function return_Color(d) {
			let color;
			if (race_gender_inspector === "Single") {
				switch (true) {
					case (d > 450):
						color = '#210009';
						break;
					case (d > 400):
						color = '#560019';
						break;
					case (d > 350):
						color = '#800026';
						break;
					case (d > 300):
						color = '#BD0026';
						break;
					case (d > 250):
						color = '#E31A1C';
						break;
					case (d > 200):
						color = '#FC4E2A';
						break;
					case (d > 150):
						color = '#FD8D3C';
						break;
					case (d > 100):
						color = '#FEB24C';
						break;
					case (d > 50):
						color = '#FED976';
						break;
					case (d == null):
						color = '#BEBEBE';
						break;
					default:
						color = '#FFEDA0';
						break;
				};
			} else {
				switch (true) {
					case (d >= 150):
						color = '#d73027';
						break;
					case (100 <= d && d < 150):
						color = '#f46d43';
						break;
					case (50 <= d && d < 100):
						color = '#fdae61';
						break;
					case (0 < d && d < 50):
						color = '#fee090';
						break;
					case (d == 0):
						color = '#BEBEBE';
						break;
					case (-50 < d && d < 0):
						color = '#abd9e9';
						break;
					case (-100 < d && d <= 50):
						color = '#74add1';
						break;
					case (-150 < d && d <= -100):
						color = '#4575b4';
						break;
					case (d <= -150):
						color = '#313695';
						break;
					default:
						color = '#BEBEBE';
						break;
				};

			}
			return color;
		}

		// Inspect the contents of the cache by printing all of the keys and values
		function print_cache_contents() {
			for (let i = 0; i < cache.length; i++) {
				console.log(cache[i].key);
				console.log(cache[i].value);
			}
		}


		function save_cache_to_file() {
			let cache_as_json = JSON.stringify(cache);
			download(cache_as_json, "cache_contents.txt", "text/plain");
		}

		// Add values to cache
		// Cache
		// Cache[0] = {key : key_phrase , value = {} }
		// where value is a dictionary of state and mort rate
		function add_to_cache(key_phrase, state, rate) {
			// Check if the key exists, in the cache
			// If the key does not exist, then add key
			if (key_exists(key_phrase) === false) {
				cache.push({
					key: key_phrase,
					value: {}
				});
			} else {
				// Else, append mort rate values to a dictionary portion of the key
				for (let i = 0; i < cache.length; i++) {
					if (key_phrase === cache[i].key) {
						let some_val = cache[i].value;
						some_val[state] = rate;
					};
				}
			}
		}

		function exists_in_cache(key_phrase, state) {
			// Check if the there is data in the cache for specific key phrase and state
			// return undefined if there is no entry
			let return_val = undefined;
			for (let i = 0; i < cache.length; i++) {
				if (key_phrase === cache[i].key) {
					return_val = cache[i].value[state];
					break;
				}
			}
			return return_val;
		}

		function key_exists(key_phrase) {
			// Check if key already exists in the cache
			let return_val = false;
			for (let i = 0; i < cache.length; i++) {
				if (key_phrase === cache[i].key) {
					return_val = true;
					break;
				}
			}
			return return_val;
		}

		function populate_cache() {
			// helper function to iterate through all of the options in the multiple dropdown Screven
			// used to generate cache data
			let temp_g1 = document.getElementById('dd_gender_multiple1').options;
			let temp_r1 = document.getElementById('dd_race_multiple1').options;
			let temp_g2 = document.getElementById('dd_gender_multiple2').options;
			let temp_r2 = document.getElementById('dd_race_multiple2').options;
			let i = 0;
			for (let a = 0; a < temp_g1.length; a++) {
				for (let b = 0; b < temp_r1.length; b++) {
					for (let c = 0; c < temp_g2.length; c++) {
						for (let d = 0; d < temp_r2.length; d++) {
							g1 = temp_g1[a].value;
							r1 = temp_r1[b].value;
							g2 = temp_g2[c].value;
							r2 = temp_r2[d].value;
							reload_based_on_priority();
							console.log(cache.length);
						}
					}
				}
			}
			//save_cache_to_file();
		}

		function return_state_information(state_name, gender, race) {
			// return information about the state's heart disease mortality rate
			let mort_rate_val = 0;
			for (let i = 0; i < json_data.length; i++) {
				// make sure that correct state is being looked at, and race / gender are both reporting overall
				if (json_data[i][9] === state_name && json_data[i][11] === "State" && json_data[i][21] === gender && json_data[i][23] === race) {
					// GeographicalLevel = "State"
					mort_rate_val = json_data[i][15];
					break;
				}
			}
			// return the rounded value
			if (mort_rate_val < 1) {
				return_str = "Insufficient information";
			} else {
				return_str = Math.round(mort_rate_val) + "/100K people";
			}
			return [return_str, mort_rate_val];
		};

		function return_county_information(county, state, gender, race) {
			// return information about the state's heart disease mortality rate
			let mort_rate_val = 0;
			for (let i = 0; i < json_data.length; i++) {
				// make sure that correct state is being looked at, and race / gender are both reporting overall
				if (json_data[i][9] === state && json_data[i][10].includes(county) && json_data[i][11] === "County" && json_data[i][21] === gender && json_data[i][23] === race) {
					// GeographicalLevel = "County"
					mort_rate_val = json_data[i][15];
					break;
				}
			}
			// return the rounded value
			if (mort_rate_val < 1) {
				return_str = "Insufficient information";
			} else {
				return_str = Math.round(mort_rate_val) + "/100K people";
			}
			return [return_str, mort_rate_val];
		}

		function return_state_information_difference(state_name) {
			// variables that will be used
			let mort_rate_difference = 0;
			// value_1` and value_2 are undefined at this point, will be used to know when to break out of loop
			let value_1;
			let value_2;
			for (let i = 0; i < json_data.length; i++) {
				// iterate through the json array and look for the specific state
				if (json_data[i][9] === state_name && json_data[i][11] === "State") {
					// once the state is correct, then look whether the gender and race for value 1 matches
					if (json_data[i][21] === g1 && json_data[i][23] === r1) {
						value_1 = json_data[i][15];
					}
					// once the state is correct, then look whether the gender and race for value 2 matches
					if (json_data[i][21] === g2 && json_data[i][23] === r2) {
						value_2 = json_data[i][15];
					}
					// once the two values are found, break out of the loop
					if (value_1 != undefined && value_2 != undefined) {
						break;
					}
				}
			}
			// check whether the values are null, if they are null, then it makes no sense to return a numeric difference
			if (value_1 === null || value_2 === null) {
				return_str = "Insufficient information";
			} else {
				denom = (parseFloat(value_1) + parseFloat(value_2)) / 2;
				num = parseFloat(value_1) - parseFloat(value_2);
				mort_rate_difference = Math.round((num / denom) * 100);
				return_str = mort_rate_difference + "%";
			}
			value_1 = value_1 == null ? "Insufficient information" : Math.round(value_1);
			value_2 = value_2 == null ? "Insufficient information" : Math.round(value_2);
			return [return_str, mort_rate_difference, value_1, value_2];
		};



		function return_county_information_difference(county, state) {
			// variables that will be used
			let mort_rate_difference = 0;
			// value_1` and value_2 are undefined at this point, will be used to know when to break out of loop
			let value_1;
			let value_2;
			for (let i = 0; i < json_data.length; i++) {
				// iterate through the json array and look for the specific county
				if (json_data[i][9] === state && json_data[i][10].includes(county) && json_data[i][11] === "County") {
					// once the county is correct, then look whether the gender and race for value 1 matches
					if (json_data[i][21] === g1 && json_data[i][23] === r1) {
						value_1 = json_data[i][15];
					}
					// once the county is correct, then look whether the gender and race for value 2 matches
					if (json_data[i][21] === g2 && json_data[i][23] === r2) {
						value_2 = json_data[i][15];
					}
					// once the two values are found, break out of the loop
					if (value_1 != undefined && value_2 != undefined) {
						break;
					}
				}
			}
			// check whether the values are null, if they are null, then it makes no sense to return a numeric difference
			if (value_1 === null || value_2 === null) {
				return_str = "Insufficient information";
			} else {
				denom = (parseFloat(value_1) + parseFloat(value_2)) / 2;
				num = parseFloat(value_1) - parseFloat(value_2);
				mort_rate_difference = Math.round((num / denom) * 100);
				return_str = mort_rate_difference + "%";
			}
			value_1 = value_1 == null ? "Insufficient information" : Math.round(value_1);
			value_2 = value_2 == null ? "Insufficient information" : Math.round(value_2);
			return [return_str, mort_rate_difference, value_1, value_2];
		}

		// Set constraint bounds on the map so that users are not able to contonously scroll away
		var southWest = L.latLng(5, -175),
			northEast = L.latLng(80, -25),
			mybounds = L.latLngBounds(southWest, northEast);


		// setview 4 zoom and coordinates to middle of United States
		var map = L.map('map', {
			// wheel mouse zoom options to enable a smoooth zooming function
			zoomDelta: 0.50,
			zoomSnap: 0,
			wheelPxPerZoomLevel: 50
			// setView defines the center of the map
		}).setView([37.8, -98], current_zoom).setMaxBounds(mybounds);

		map.on('zoomend', function() {
			// based on the zoom of the map, determine which layer to show/remove
			// once the map is swtiched, update the global layer variable
			// update the informational section in top right
			if (map.getZoom() >= zoom_state_county_split && map_type_level != "county") {
				map.addLayer(geojson_county);
				map.removeLayer(geojson);
				map_type_level = "county";
			} else if (map.getZoom() <= zoom_state_county_split && map_type_level != "state") {
				map.addLayer(geojson);
				map.removeLayer(geojson_county);
				map_type_level = "state";
			}
			info.update();
		});

		L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
			// define the min Zoom so the user doesn't see a grey background
			maxZoom: 10,
			minZoom: 2,
			attribution: 'Map data: <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors ',
			id: 'mapbox.light'
		}).addTo(map);

		graph_selection_change();
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Info shows the state information to the user in the top right side of the map
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		var info = L.control();

		info.onAdd = function(map) {
			this._div = L.DomUtil.create('div', 'info');
			this.update();
			return this._div;
		};

		info.update = function(props) {
			// based on the current layer of the map, display different information in the top right
			if (map_type_level === "state") {
				// State level zoom
				if (race_gender_inspector === "Single") {
					// Single comparison mode
					this._div.innerHTML = '<h4>US Heart Disease Mortality rate</h4>' + (props ?
						'<b>' + 'State: ' + props.name + '</b><br />' + 'Density: ' + Math.round(props.density) + ' people / mi<sup>2</sup>' + '</b><br />' + 'Mortality rate: ' + return_state_information(props.abbreviation, gender, race)[0] :
						'Hover over a state to learn more!');
				} else {
					// Multiple comparison mode
					let temp = props ? return_state_information_difference(props.abbreviation) : null;
					this._div.innerHTML = '<h4>US Heart Disease Mortality rate</h4>' + (props ?
						'<b>' + 'State: ' + props.name + '</b><br />' + 'Density: ' + Math.round(props.density) + ' people / mi<sup>2</sup>' + '</b><br />' + 'Mortality rate percentage difference: ' + temp[0] + '<br />' + "Lookup criteria 1 : Gender(" + g1 +
						") Race(" + r1 +
						') mortality rate: ' + temp[2] + '<br />' + "Lookup criteria 2 : Gender(" + g2 + ") Race(" +
						r2 + ') mortality rate: ' + temp[3] :
						'Hover over a state to learn more!');
				}
				//document.getElementById("bottomofpage").innerHTML = 'Now hovered over: ' + (props ? '<b>' + props.name : 'Nowhere');
			} else {
				// County level zoom
				if (race_gender_inspector === "Single") {
					// Single comparison mode
					this._div.innerHTML = '<h4>US Heart Disease Mortality rate</h4>' + (props ?
						'<b>' + 'County: ' + props.NAME + '</b><br />' + 'Mortality rate: ' + return_county_information(props.NAME, props.STATE, gender, race)[0] :
						'Hover over a county to learn more!');
				} else {
					// Multiple comparison mode
					let temp = props ? return_county_information_difference(props.NAME, props.STATE) : null;
					this._div.innerHTML = '<h4>US Heart Disease Mortality rate</h4>' + (props ?
						'<b>' + 'County: ' + props.NAME + '</b><br />' + 'Mortality rate percentage difference: ' + temp[0] + '<br />' + "Lookup criteria 1 : Gender(" + g1 + ") Race(" + r1 +
						') mortality rate: ' + temp[2] + '<br />' + "Lookup criteria 2 : Gender(" + g2 + ") Race(" +
						r2 + ') mortality rate: ' + temp[3] :
						'Hover over a county to learn more!');
				}
				//document.getElementById("bottomofpage").innerHTML = 'Now hovered over: ' + (props ? '<b>' + props.NAME : 'Nowhere');
			}

		};
		info.addTo(map);
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Layer controls
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		function highlightFeature(e) {
			let layer = e.target;
			stateMortRateByDensityScatter.highlight_state_selection(layer.feature.properties.name);
			layer.setStyle({
				weight: 6,
				color: 'white',
				dashArray: '',
				fillOpacity: 0.7
			});
			if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
				layer.bringToFront();
			}
			info.update(layer.feature.properties);
		}

		function highlightCountyFeature(e) {
			let layer = e.target;
			countyMortRateByStateBarChart.highlight_county_selection(layer.feature.properties.NAME, layer.feature.properties.STATE);
			layer.setStyle({
				weight: 6,
				color: 'white',
				dashArray: '',
				fillOpacity: 0.7
			});
			if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
				layer.bringToFront();
			}
			info.update(layer.feature.properties);
		}

		function resetHighlight(e) {
			// reset the style after the mouse is moved to different state
			geojson.resetStyle(e.target);
			info.update();
		}

		function resetHighlightCounty(e) {
			// reset the style after the mouse is moved to different county
			geojson_county.resetStyle(e.target);
			info.update();
		}

		function zoomToCounty(e) {
			let layer = e.target;
			map.fitBounds(e.target.getBounds());
			resetHighlight(e);
		}

		function zoomOutToState(e) {
			let layer = e.target;
			map.setView([37.8, -98], 5);
			resetHighlightCounty(e);
		}

		// this is what happens when a state is clicked on
		function click_event_handler(e) {
			let layer = e.target;
			state = e.target.feature.properties.name;
			layer.setStyle({
				weight: 6,
				color: 'white',
				dashArray: '',
				fillOpacity: 0.7,
				fillColor: 'blue'
			});
			if (selection_count < selection_max) {
				// if the selection list does not include the state, then add it to the selection_list
				if (!selection_list.includes(state)) {
					selection_count += 1;
					selection_list.push(state);
				// state is already included, so clicking again pop it off
				} else {
					if(selection_list.length > 1){
						// if the selection list is greater than 1, then delete the state
						// that the user clicks on
						var filtered = selection_list.filter(function(value, index, arr){
						    return value != state;
						});
						//console.log(filtered);
						selection_list = filtered;
						}
				}
			} else {
				selection_count = 1;
				selection_list.length = 0;
				selection_list.push(state);
			}
			// update the queue with the selection
			queue.update();
			// update Dennis's graph based on the selection
			/////////////////////////////////////////////////////////////////////////////////////////////////////////
			countyMortRateByStateBarChart.update_bars(e.target.feature.properties.abbreviation, gender, race);
			// update John's's graph based on the selection
			update_grouped_barchart(selection_list, jons_graph_type);
			/////////////////////////////////////////////////////////////////////////////////////////////////////////
		}
		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		// only let users add states to the queue, not implemented on county level



		function onEachFeature(feature, layer) {
			// state level
			// this function determines what kind of event driven functionality exists for the layers
			layer.on({
				mouseover: highlightFeature,
				mouseout: resetHighlight,
				click: click_event_handler,
				dblclick: zoomToCounty
			});
		}

		function onEachCountyFeature(feature, layer) {
			// county level
			// this function determines what kind of event driven functionality exists for the layers
			layer.on({
				mouseover: highlightCountyFeature,
				mouseout: resetHighlightCounty,
				dblclick: zoomOutToState
			});
		}
		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

		function sleep(ms) {
			// Way of letting time go by
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		function style(feature) {
			let temp;
			if (race_gender_inspector === "Single") {
				// Single mode
				// Try to get a value from cache
				cache_lookup = exists_in_cache(race_gender_inspector + gender + race, feature.properties.abbreviation);
				if (cache_lookup === undefined) {
					//console.log(feature.properties.abbreviation + " Not available in cache");
					// if the value does not exist in the cache, get the value using search on the json data
					// append the result to the cache to be used later
					temp = return_state_information(feature.properties.abbreviation, gender, race)[1];
					add_to_cache(race_gender_inspector + gender + race, feature.properties.abbreviation, temp);
				} else {
					// get the value from the cache
					temp = cache_lookup;
					//console.log("returned from cache");
				}
				returncolor = return_Color(temp);
			} else {
				// Multiple mode
				// Try to get a value from cache
				cache_lookup = exists_in_cache(race_gender_inspector + g1 + r1 + g2 + r2, feature.properties.abbreviation);
				if (cache_lookup === undefined) {
					//console.log(feature.properties.abbreviation + " Not available in cache");
					// if the value does not exist in the cache, get the value using search on the json data
					// append the result to the cache to be used later
					temp = return_state_information_difference(feature.properties.abbreviation)[1];
					add_to_cache(race_gender_inspector + g1 + r1 + g2 + r2, feature.properties.abbreviation, temp);
				} else {
					temp = cache_lookup;
					// get the value from the cache
					//console.log("returned from cache");
				}
				returncolor = return_Color(temp);
			}
			return {
				weight: 3,
				opacity: 1,
				color: 'white',
				dashArray: '3',
				fillOpacity: 0.7,
				fillColor: returncolor
			};
		};

		function county_style(feature) {
			let temp;
			if (race_gender_inspector === "Single") {
				// Single mode
				// Try to get a value from cache
				cache_lookup = exists_in_cache(race_gender_inspector + gender + race, feature.properties.NAME + feature.properties.STATE);
				if (cache_lookup === undefined) {
					//console.log("no cache");
					// if the value does not exist in the cache, get the value using search on the json data
					// append the result to the cache to be used later
					temp = return_county_information(feature.properties.NAME, feature.properties.STATE, gender, race)[1];
					add_to_cache(race_gender_inspector + gender + race, feature.properties.NAME + feature.properties.STATE, temp);
				} else {
					// get the value from the cache
					temp = cache_lookup;
					//console.log("returned from cache");
				}
				returncolor = return_Color(temp);
			} else {
				// Multiple mode
				//temp = return_county_information_difference(feature.properties.NAME)[1];
				cache_lookup = exists_in_cache(race_gender_inspector + g1 + r1 + g2 + r2, feature.properties.NAME + feature.properties.STATE);
				if (cache_lookup === undefined) {
					//console.log("no cache");
					// if the value does not exist in the cache, get the value using search on the json data
					// append the result to the cache to be used later
					temp = return_county_information_difference(feature.properties.NAME, feature.properties.STATE)[1];
					add_to_cache(race_gender_inspector + g1 + r1 + g2 + r2, feature.properties.NAME + feature.properties.STATE, temp);
				} else {
					// get the value from the cache
					temp = cache_lookup;
					//console.log("returned from cache");
				}
				returncolor = return_Color(temp);
			}
			return {
				weight: 1,
				opacity: 1,
				color: 'white',
				dashArray: '3',
				fillOpacity: 0.5,
				fillColor: returncolor
			};
		};


		// for each feature in the geojson file, set the style and add it to the map
		geojson = L.geoJson(statesData, {
			style: style,
			onEachFeature: onEachFeature
		}).addTo(map);

		function load_county_data() {
			geojson_county = L.geoJson(countyData, {
				style: county_style,
				onEachFeature: onEachCountyFeature
			})
		}
		// load the data asynchrously
		setTimeout(load_county_data, 0);
		map.attributionControl.addAttribution('Heart disease data: <a target="_blank" href="https://catalog.data.gov/dataset/heart-disease-mortality-data-among-us-adults-35-by-state-territory-and-county-5fb7c">US Heart Disease Mortality Data</a>');

		//
		function reload_geojson() {
			geojson.eachLayer(async function(layer) {
				// get the current color of the respective layer
				let existing_color = layer.options.fillColor;
				let return_style;

				// get the new color based on the selection of the data
				return_style = style(layer.feature);
				//console.log('State: ' + layer.feature.properties.name + ' Existing fill color' + existing_color + ' - ' + return_style.fillColor);
				if (existing_color != return_style.fillColor) {
					// if the existing color does not match the new color that will be applied to the layer
					// signal to the user by changing the outline of the state in a blinking red and white fashion
					// sleep the change for 250 ms seconds so users will be able to register
					let sleep_time = 50;
					let number_of_blinks = 2;
					for (let i = 0; i < number_of_blinks; i++) {
						layer.setStyle({
							color: 'red'
							//fillColor: return_style.fillColor
						});
						await sleep(sleep_time);
						layer.setStyle({
							color: 'white'
							//fillColor: existing_color
						});
						i < number_of_blinks - 1 ? await sleep(sleep_time) : 'nothing';
					}
				};
				layer.setStyle(return_style);
			});
		}


		function reload_geojson_county() {
			geojson_county.eachLayer(async function(layer) {
				// get the current color of the respective layer
				// get the new color based on the selection of the data
				let existing_color = layer.options.fillColor;
				let return_style;
				// get the new color based on the selection of the data
				return_style = county_style(layer.feature);

				//console.log('State: ' + layer.feature.properties.name + ' Existing fill color' + existing_color + ' - ' + return_style.fillColor);
				if (existing_color != return_style.fillColor) {
					// if the existing color does not match the new color that will be applied to the layer
					// signal to the user by changing the outline of the state in a blinking red and white fashion
					// sleep the change for 250 ms seconds so users will be able to register
					let sleep_time = 20;
					let number_of_blinks = 1;
					for (let i = 0; i < number_of_blinks; i++) {
						layer.setStyle({
							color: 'red'
						});
						await sleep(sleep_time);
						layer.setStyle({
							color: 'white'
						});
						i < number_of_blinks - 1 ? await sleep(sleep_time) : 'nothing';
					}
				};
				layer.setStyle(return_style);
			});
		}
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Dropdown allows the user to make a selection to view the data by race or gender
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		var dropdown = L.control({
			position: 'bottomright'
		});

		dropdown.onAdd = function(e) {
			// add some values to the dropdown
			this._div = L.DomUtil.create('div', 'info');
			this._div.innerHTML = '<div style="text-align: center;"> <h4>Race / Gender interaction</h4>' +
				'<label onchange="radio_change()"><input type="radio" name="radio_comp_type" value="Single" checked><b>Single mode</b></label>' +
				'&nbsp;&nbsp;&nbsp;&nbsp;' +
				'<label onchange="radio_change()"><input type="radio" name="radio_comp_type" value="Multiple"><b>Multiple mode</b></label><br />' +

				'<div id = "single_selection_dropdown" style="text-align: left; padding-top: 5px; padding-bottom: 5px">' +
				'<div style="padding-left: 5px; padding-bottom: 5px">Gender - <select id="dd_gender_single1"><option>Overall</option><option>Female</option><option>Male</option></select></div>' +
				'<div style="padding-left: 5px; padding-bottom: 5px">Race - ' + '<select id="dd_race_single1"><option>Overall</option><option>White</option>' +
				'<option>Black</option><option>Asian and Pacific Islander</option><option>American Indian and Alaskan Native</option><option>Hispanic</option></select></div>' +
				'</div>' +

				'<div id = "multiple_selection_dropdown" style="display:none; text-align: left; padding-top: 5px; padding-bottom: 5px">' +
				'<div style="padding-left: 5px; padding-bottom: 5px">1st lookup criteria : <br /> Gender - <select id="dd_gender_multiple1"><option>Overall</option><option>Female</option><option>Male</option></select>' +
				'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' +
				'Race - <select id="dd_race_multiple1" ><option>Overall</option><option>White</option>' +
				'<option>Black</option><option>Asian and Pacific Islander</option><option>American Indian and Alaskan Native</option><option>Hispanic</option></select></div>' +

				'<div style="padding-left: 5px; padding-bottom: 5px">2nd lookup criteria : <br /> Gender - <select id="dd_gender_multiple2"><option>Overall</option><option>Female</option><option>Male</option></select>' +
				'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' +
				'Race - <select id="dd_race_multiple2" ><option>Overall</option><option>White</option>' +
				'<option>Black</option><option>Asian and Pacific Islander</option><option>American Indian and Alaskan Native</option><option>Hispanic</option></select></div>' +
				'</div>' +

				'<div style="padding-bottom: 5px"><button class="btn" type="button" style="margin: auto" onclick="execute()">Update Map</button></div>' +
				'</div>'
			this._div.firstChild.onmousedown = this._div.firstChild.ondblclick = L.DomEvent.stopPropagation;
			return this._div;
		};


		function reload_based_on_priority() {
			if (map_type_level === "state") {
				// if the current zoom is state, reload state level geojson
				reload_geojson();
				reload_geojson_county();
			} else {
				// if the current zoom is county, reload state level geojson
				reload_geojson_county();
				reload_geojson();
			}
		}

		function graph_selection_change() {
			// Based on the radio button selection, display different set of divs to the user
			// first, get the radio button value to determine where the user has clicked
			let curr_selection;
			let radio_choice = document.getElementsByName("radio_graph_select");
			for (let i = 0; i < radio_choice.length; i++) {
				if (radio_choice[i].checked) {
					curr_selection = radio_choice[i].value;
					// once the current selection is found, then break out from the loop and save the value
					break;
				}
			}
			if (curr_selection === "county_bar_chart") {
				document.getElementById("countyMortRateByState").style.display = "block";
				document.getElementById("stateMortRateByDensity").style.display = "none";
				document.getElementById("groupedBarChartButtons").style.display = "none";
			} else if (curr_selection === "density_vs_mort_rate_scatter") {
				document.getElementById("countyMortRateByState").style.display = "none";
				document.getElementById("stateMortRateByDensity").style.display = "block";
				document.getElementById("groupedBarChartButtons").style.display = "none";
			} else if (curr_selection === "state_comp_bar_chart") {
				update_grouped_barchart(selection_list, jons_graph_type);
				document.getElementById("countyMortRateByState").style.display = "none";
				document.getElementById("stateMortRateByDensity").style.display = "none";
				document.getElementById("groupedBarChartButtons").style.display = "block";

			}
		}

		function execute() {
			// save the choices from the dropdowns and go forward with the animation
			let changed_vals = [];
			changed_vals = save_dropdown_options();
			drop_down_operator(true);
			reload_based_on_priority();
			setTimeout(function() {
				drop_down_operator(false);
			}, 500);
			if (race_gender_inspector === "Single") {
				// save the choices from the dropdowns and go forward with the animation
				if (selection_list.length > 0) {
					// Update Denni's graph
					let state_abbreviation = get_state_abbreviation(selection_list[selection_list.length - 1]);
					let county_data_of_state = get_county_data_of_state(state_abbreviation, gender, race);
					countyMortRateByStateBarChart.update_bars(get_state_abbreviation(selection_list[selection_list.length - 1]), gender, race);

					// Update John's graph
					// changed_vals.length == 0 ? update_grouped_barchart(get_state_data_overall(selection_list), jons_graph_type) : console.log("It is 0")
					// changed_vals.length == 1 ? update_grouped_barchart(get_state_data_overall(selection_list), changed_vals[0]) : console.log("It is 1")
					// changed_vals.length == 2 ? update_grouped_barchart(get_state_data_overall(selection_list), "overall") : console.log("It is 2")
					if (changed_vals.length == 0) {
						// if no change to single mode dropdowns, then use existing
						jons_graph_type == "race" ? update_grouped_barchart(selection_list, "race") : "nothing";
						jons_graph_type == "gender" ? update_grouped_barchart(selection_list, "gender") : "nothing";
						jons_graph_type == "overall" ? update_grouped_barchart(selection_list, "overall") : "nothing";
					} else if (changed_vals.length == 1) {
						let type = changed_vals[0];
						type == "race" ? update_grouped_barchart(selection_list, type) : "nothing";
						type == "gender" ? update_grouped_barchart(selection_list, type) : "nothing";
						jons_graph_type = type;
					} else {
						update_grouped_barchart(selection_list, "overall");
						jons_graph_type = "overall";
					}
				}
			}
		}

		window.radio_change = function() {
			// Based on the radio button selection, display different set of divs to the user
			// first, get the radio button value to determine where the user has clicked
			let curr_selection;
			let radio_choice = document.getElementsByName("radio_comp_type");
			for (let i = 0; i < radio_choice.length; i++) {
				if (radio_choice[i].checked) {
					curr_selection = radio_choice[i].value;
					// once the current selection is found, then break out from the loop and save the value
					break;
				}
			}
			let changed_vals = save_dropdown_options();
			// When the user changes selection using the radio button, save user's choices and then
			// change the radio button options
			race_gender_inspector = curr_selection;
			if (race_gender_inspector === "Multiple") {
				document.getElementById("single_selection_dropdown").style.display = "none";
				document.getElementById("multiple_selection_dropdown").style.display = "block";
			} else if (race_gender_inspector === "Single") {
				document.getElementById("single_selection_dropdown").style.display = "block";
				document.getElementById("multiple_selection_dropdown").style.display = "none";
			}
			legend.update();
			setTimeout(reload_based_on_priority(), 0);
		}

		function drop_down_operator(bool_val) {
			// disable or enable dropdowns during transitions
			// this will block the user from selecting other options while the animations are in play
			document.getElementById("dd_gender_single1").disabled = bool_val;
			document.getElementById("dd_race_single1").disabled = bool_val;
			document.getElementById("dd_gender_multiple1").disabled = bool_val;
			document.getElementById("dd_race_multiple1").disabled = bool_val;
			document.getElementById("dd_gender_multiple2").disabled = bool_val;
			document.getElementById("dd_race_multiple2").disabled = bool_val;
		};

		function save_dropdown_options() {
			// for all of the dropdowns, save the current selections into a global variable to be
			// used in the animation
			let changed_vals = [];
			if (gender != document.getElementById("dd_gender_single1").value) {
				changed_vals.push("gender");
			}
			gender = document.getElementById("dd_gender_single1").value;
			if (race != document.getElementById("dd_race_single1").value) {
				changed_vals.push("race");
			}
			race = document.getElementById("dd_race_single1").value;
			g1 = document.getElementById("dd_gender_multiple1").value;
			g2 = document.getElementById("dd_gender_multiple2").value;
			r1 = document.getElementById("dd_race_multiple1").value;
			r2 = document.getElementById("dd_race_multiple2").value;
			return changed_vals;
		}
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Queue displays the states that the user selects by clicking, currently there can be only two states in the queue at a time
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		var queue = L.control({
			position: 'topcenter'
		});

		queue.onAdd = function(e) {
			// Initially, make the div invisible to the user
			this._div = L.DomUtil.create('div', 'info');
			this._div.style.opacity = "0.0";
			return this._div;
		}

		queue.update = function(props) {
			// show the div if the user clicks any state and wants to add it to the queue
			// set the opacity of the div to 1.0
			this._div.style.opacity = "1.0";
			s = this._div.style;
			// update the contents of the div
			this._div.innerHTML = '<b>Items in the selection queue: ' + selection_list + '</b>';
			// provide smooth fadeout effect to the div
			fade_Out_Effect(this._div);
		}

		function fade_Out_Effect(div) {
			// decrease the opacity of the div by 0.01 every 20 ms, to provide a smooth fadeout effect
			let fadeEffect = setInterval(function() {
				if (!div.style.opacity) {
					div.style.opacity = 1;
				}
				if (div.style.opacity > 0) {
					div.style.opacity -= 0.01;
				} else {
					clearInterval(fadeEffect);
				}
			}, 100);
		}
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Moved all my things to static/countyMortRateByStateBarChart.js
		let body = document.getElementsByTagName("body")[0];

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Legend displays the color of the states that is corresponding to the mortaility rate
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		var legend = L.control({
			position: 'bottomleft'
		});

		legend.onAdd = function(map) {
			// create a div with legend styling
			this._div = L.DomUtil.create('div', 'info legend');
			this.update();
			return this._div;
		};

		legend.update = function() {
			if (race_gender_inspector === "Multiple") {
				resp_labels = [];
				partitions = [-150, -100, -50, 0, 50, 100, 150];
				resp_labels.push('<i style="background:' + return_Color(-151) + '"></i> ' + '-150% or more');
				for (let i = 0; i < partitions.length - 1; i++) {
					from = partitions[i];
					to = partitions[i + 1];
					if (i == 3) {
						resp_labels.push('<i style="background:' + return_Color(0) + '"></i> ' + '0% or no data');
					}
					resp_labels.push(
						'<i style="background:' + return_Color(from + 1) + '"></i> ' +
						from + ' to ' + to + '%');
				}
				resp_labels.push('<i style="background:' + return_Color(151) + '"></i> ' + '150% or more');
				this._div.innerHTML = '<h4>Mortality rate % difference</h4>' + resp_labels.join('<br>');
			} else if (race_gender_inspector === "Single") {
				resp_labels = [];
				partitions = [0, 50, 100, 150, 200, 250, 300, 350, 400, 450];
				resp_labels.push('<i style="background:' + return_Color(null) + '"></i> ' + 'Insufficient Data');
				for (let i = 0; i < partitions.length; i++) {
					// from is the first range and to is the second
					from = partitions[i];
					to = partitions[i + 1];
					resp_labels.push(
						'<i style="background:' + return_Color(from + 1) + '"></i> ' +
						from + (to ? ' to ' + to + "" : '+'));
				}
				this._div.innerHTML = '<h4>Mortality rate</h4>' + resp_labels.join('<br>');
			}
		};
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// add legend to map
		legend.addTo(map);
		// add dropdown to the map
		dropdown.addTo(map);
		// add queue to the map
		queue.addTo(map);
		// disable double click from zooming in the map
		map.doubleClickZoom.disable();

		queue.update();
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		var w = Math.round(body.clientWidth * 0.7);
		var h = Math.round(body.clientHeight * 0.3);

		function get_race_abbreviation(race) {
			if(race === "Asian and Pacific Islander"){
				race = "APIA";
			} else if(race === "American Indian and Alaskan Native"){
				race = "AI/AN";
			}
			return race;
		}

		function get_state_data(state_name, strata) {
			var data = [];

			if(strata == "overall"){
				for (let j = 0; j < state_name.length; j++) {
					for (let i = 0; i < json_data.length; i++) {
						if (json_data[i][10] === state_name[j] && json_data[i][11] === "State" && json_data[i][21] === "Overall" && json_data[i][23] === "Overall") {
							data.push({
								state: json_data[i][10],
								mort_rate: parseFloat(json_data[i][15]) || 0,
								gender: json_data[i][21],
								race: get_race_abbreviation(json_data[i][23])
							});
						}
					}
				}
			}

			if (strata == "gender"){
				for (let j = 0; j < state_name.length; j++) {
					for (let i = 0; i < json_data.length; i++) {
						if (json_data[i][10] === state_name[j] && json_data[i][11] === "State" && json_data[i][21] != "Overall" && json_data[i][23] === "Overall"){
							data.push({
								state: json_data[i][10],
								mort_rate: parseFloat(json_data[i][15]) || 0,
								gender: json_data[i][21],
								race: get_race_abbreviation(json_data[i][23])
							});
						}
					}
				}
			}

			if(strata == "race"){
				for (let j = 0; j < state_name.length; j++) {
					for (let i = 0; i < json_data.length; i++) {
						if (json_data[i][10] === state_name[j] && json_data[i][11] === "State" && json_data[i][21] === "Overall" && json_data[i][23] != "Overall"){
							data.push({
								state: json_data[i][10],
								mort_rate: parseFloat(json_data[i][15]) || 0,
								gender: json_data[i][21],
								race: get_race_abbreviation(json_data[i][23])
							});
						}
					}
				}
			}

		return data;
		};

		function graph_bar_color(d) {
			let color;
			switch (true) {
				case (d > 450):
				color = '#210009';
				break;
				case (d > 400):
				color = '#560019';
				break;
				case (d > 350):
				color = '#800026';
				break;
				case (d > 300):
				color = '#BD0026';
				break;
				case (d > 250):
				color = '#E31A1C';
				break;
				case (d > 200):
				color = '#FC4E2A';
				break;
				case (d > 150):
				color = '#FD8D3C';
				break;
				case (d > 100):
				color = '#FEB24C';
				break;
				case (d > 50):
				color = '#FED976';
				break;
				case (d == null || d == 0):
				color = '#BEBEBE';
				break;
				default:
				color = '#FFEDA0';
				break;
			};
			return color;
		}

		function update_grouped_barchart(state_data, strata) {
			// adapted from https://stackoverflow.com/questions/45211408/making-a-grouped-bar-chart-using-d3-js

			// remove old chart
			chart.selectAll("*").remove()
			
			// get data for this state, strata
			var data = get_state_data(state_data,strata);

			console.log(data);

			// if strata is state, set to "" for graph
			if(strata === "overall"){
				strata = "";
			};

			var color = d3.scaleOrdinal(d3.schemeCategory10);

			color.domain(data.map(function(d) {
				return d[strata];
			}));

			// x is main axis
			var x = d3.scaleBand()
				.rangeRound([0, w])
				.padding(0.1)
				.domain(data.map(function(d) {
					return d.state
				}));			

			// x1 is secondary axis
			var x1 = d3.scaleBand()
				.rangeRound([0, x.bandwidth()])
				.padding(0.05)
				.domain(data.map(function(d) {
					return d[strata];
				}));


			// set up y axis
			var y = d3.scaleLinear().rangeRound([h, 0]);
			var ymaxdomain = d3.max(data, function(d) {
				return d.mort_rate;
			});
			y.domain([0, ymaxdomain]);

			var g = chart.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");

			var bars = g.append("g")
				.selectAll("g")
				.data(data)
				.enter()
				.append("g")


			var tip2 = d3.tip()
				.attr("class", "tooltip2")
				.html(function(d) {
					return d.mort_rate
				});

			bars.call(tip2);

			// var bars = states.selectAll("rect")
			// 	.data(function(d) {
			// 		return [d]
			// 	})

			bars.attr("transform", function(d) {
					return "translate(" + x(d.state) + ",0)";
				})
				.selectAll("rect")
				.data(function(d) {
					return [d]
				})
				.enter()
				.append("rect")
				.attr("x", function(d, i) {
					return x1(d[strata])
				})
				.attr("y", function(d) {
					return y(d.mort_rate);
				})
				.attr("width", x1.bandwidth())
				.attr("height", function(d) {
					return h - y(d.mort_rate);
				})
				.attr("fill", function(d) {
					return graph_bar_color(d.mort_rate)
				})
				.attr("opacity", 0.7)
				.on("mouseover", tip2.show)
				.on("mouseout", tip2.hide)

			// add x-axis
			g.append("g")
				.attr("class", "axis")
				.attr("transform", "translate(0," + h + ")")
				.call(d3.axisBottom(x))
				.selectAll("text")
				.attr("y",15)

			// add secondary x-axis
			bars.append("g")
				.attr("class", "axis")
				.attr("transform", "translate(0," + h + ")")
				.call(d3.axisBottom(x1).tickSize(0));

			// add y-axis
			g.append("g")
				.attr("class", "axis")
				.call(d3.axisLeft(y).ticks(null, "s"))
				.append("text")
				.attr("x", 2)
				.attr("y", y(y.ticks().pop()) + 0.5)
				.attr("dy", "0.32em")
				.attr("fill", "#000")
				.attr("font-weight", "bold")
				.attr("text-anchor", "start")
		};

		d3.select("#groupedBarChartButtons")
			.select("#selectOverall")
			.on("click", function() {
				if (selection_list.length > 0) {
					//New values for dataset
					jons_graph_type = "overall";
					update_grouped_barchart(selection_list,"overall");
				}
			});

		d3.select("#groupedBarChartButtons")
			.select("#selectGender")
			.on("click", function() {
				if (selection_list.length > 0) {
					//New values for dataset
					jons_graph_type = "gender";
					update_grouped_barchart(selection_list, "gender");
				}
			});

		d3.select("#groupedBarChartButtons")
			.select("#selectRace")
			.on("click", function() {
				if (selection_list.length > 0) {
					//New values for dataset
					jons_graph_type = "race";
					update_grouped_barchart(selection_list, "race");
				}
			});

		var margin = {
			top: 20,
			right: 20,
			bottom: 30,
			left: 40
		};

		//Create SVG element
		var chart = d3.select("#jonsgraph")
			.append("svg")
			.attr("width", w + margin.left + margin.right)
			.attr("height", h + margin.top + margin.bottom);
	</script>

</body>

</html>
