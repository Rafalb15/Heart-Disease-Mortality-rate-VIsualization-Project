<!DOCTYPE html>
<html class="gr__leafletjs_com">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>Heart Disease Mortality Data Among US Adults (population age 35+)</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="shortcut icon" type="image/x-icon" href="https://leafletjs.com/examples/choropleth/docs/images/favicon.ico">
	<link rel="stylesheet" href="/static/leaflet.css" crossorigin="">
	<!-- integrity="sha512-puBpdR0798OZvTTbP4A8Ix/l+A4dHDD0DGqYW6RQ+9jxkRFclaxxQb/SJAWZfWAkuyeQUytO7+7N4QKrDh+drA==" -->
	<script src="/static/leaflet.js" crossorigin=""></script>
	<!-- integrity="sha512-QVftwZFqvtRNi0ZyCtsznlKSWOStnDORoefr1enyq5mVL4tmKB3S/EnC3rRJcxCPavG10IcrVGSmPh6Qw5lwrg==" -->
	<script src="/static/d3.js"></script>


	<style>
		html,
		body {
			height: 100%;
			margin: 10;
		}
	</style>

	<style type="text/css">
		/* copied from lab 6 - Dennis */
		#tooltip {
			position: absolute;
			width: 200px;
			height: auto;
			padding: 10px;
			background-color: white;
			-webkit-border-radius: 10px;
			-moz-border-radius: 10px;
			border-radius: 10px;
			-webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			-moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			pointer-events: none;
		}

		#tooltip.hidden {
			display: none;
		}

		#tooltip p {
			margin: 0;
			font-family: sans-serif;
			font-size: 16px;
			line-height: 20px;
		}
	</style>



	<style type="text/css">
		/* copied from Dennis above - Jon */
		#tooltip2 {
			position: absolute;
			width: 200px;
			height: auto;
			padding: 10px;
			background-color: white;
			-webkit-border-radius: 10px;
			-moz-border-radius: 10px;
			border-radius: 10px;
			-webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			-moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
			pointer-events: none;
		}

		#tooltip2.hidden {
			display: none;
		}

		#tooltip2 p {
			margin: 0;
			font-family: sans-serif;
			font-size: 16px;
			line-height: 20px;
		}
	</style>

	<style>#map { width: 100%; height: 80%; }
.info { padding: 6px 8px; font: 14px/16px Arial, Helvetica, sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px; } .info h4 { margin: 0 0 5px; color: #777; }
.legend { text-align: left; line-height: 18px; color: #555; } .legend i { width: 18px; height: 18px; float: left; margin-right: 2px; opacity: 0.7; } .queue {padding: 6px 8px; font: 14px/16px Arial, Helvetica, sans-serif; background: white; background: rgba(255,255,255,0.8); box-shadow: 0 0 15px rgba(0,0,0,0.2); border-radius: 5px;}
</style>
	<script src="chrome-extension://mooikfkahbdckldjjndioackbalphokd/assets/prompt.js"></script>

</head>

<body data-gr-c-s-loaded="true">
	<!-- #################################### TOP OF PAGE ############################################################################## -->
	<div>
		<h4>US Heart Disease Mortality rate</h4>
	</div>
	<div id="map" class="leaflet-container leaflet-touch leaflet-fade-anim leaflet-grab leaflet-touch-drag leaflet-touch-zoom" tabindex="0" style="position: relative;"></div>
	<!-- #################################### BOTTOM OF PAGE ############################################################################## -->
	<div id="bottomofpage"></div>
	<!-- #################################### bottomer? of page ############################################################################## -->
	<!-- copied from lab 6 - Dennis Shen -->
	<div id="tooltip" class="hidden">
		<p><strong><span id="tooltipLabel">Important Label Heading</span></strong></p>
		<p><span id="value">100</span></p>
	</div>
	<div id="graphButtons"><button type="button" id="refreshGraph">Refresh Graph</button><button type="button" id="sortGraph">sort graph</button></div>

	<!-- #################################### bottomest? of page ################################################################### -->
	<!-- stolen from Dennis - Jon -->

	<div id="tooltip2" class="hidden">
		<p><strong><span id="tooltipLabel">Important Label Heading</span></strong></p>
		<p><span id="value">100</span></p>
	</div>
	<div id="groupedBarChartButtons"><button type="button" id="selectOverall">Overall</button><button type="button" id="selectGender">Gender</button><button type="button" id="selectRace">Race</button></div>

	<!-- #################################### SCRIPTS ############################################################################## -->
	<!-- source: https://leafletjs.com/examples/choropleth/ -->
	<script type="text/javascript" src="/static/us-states.js"></script>

	<!-- this is the data from the data.gov -->
	<script type="text/javascript" src="/static/data_as_json.js"></script>

	<!-- this is the data from http://eric.clst.org/tech/usgeojson/ -->
	<script type="text/javascript" src="/static/gz_2010_us_050_00_20m.js"></script>


	<script type="text/javascript">
		// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //
		// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //
		// GLOBAL VARIABLES
		var json_data = heart_disease_data.data;
		var geojson;
		var geojson_county;
		var selection_count = 0;
		var selection_max = 2;
		var zoom_state_county_split = 6.0;
		var map_type_level = "state";
		var current_zoom = 4;
		// default values for race and gender
		var race = "Overall";
		var gender = "Overall";
		// values used to store the values in the dropdowns for multiple criteria view
		var g1 = "Overall";
		var g2 = "Overall";
		var r1 = "Overall";
		var r2 = "Overall";
		var race_gender_inspector = "Single"
		// cache is used to store the already retrieved mort rate values for various criterias
		// avoiding having to search through the whole data, thus saving time
		var cache = [];
		// contains the list of states that have been clicked on, only two states are allowed to be selected at a timeout
		// selecting additional state will override previous selections
		var selection_list = [];
		// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //
		// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ //

		function return_avg(array) {
			// find the average from a list, return the average only if the length of the array is more than 0
			var sum, avg = 0;
			if (array.length != 0) {
				sum = array.reduce(function(a, b) {
					return a + b;
				});
				avg = sum / array.length;
				return Math.round(avg);
			} else {
				return "Insufficient information";
			}

		}

		// Return color HEX color based on d value
		// Single map mode has a sequential map style
		// Multiple map mode has a diverging map style
		function return_Color(d) {
			var color;
			if (race_gender_inspector === "Single") {
				switch (true) {
					case (d > 450):
						color = '#210009';
						break;
					case (d > 400):
						color = '#560019';
						break;
					case (d > 350):
						color = '#800026';
						break;
					case (d > 300):
						color = '#BD0026';
						break;
					case (d > 250):
						color = '#E31A1C';
						break;
					case (d > 200):
						color = '#FC4E2A';
						break;
					case (d > 150):
						color = '#FD8D3C';
						break;
					case (d > 100):
						color = '#FEB24C';
						break;
					case (d > 50):
						color = '#FED976';
						break;
					default:
						color = '#FFEDA0';
						break;
				};
			} else {
				switch (true) {
					case (d >= 150):
						color = '#d73027';
						break;
					case (100 <= d && d < 150):
						color = '#f46d43';
						break;
					case (50 <= d && d < 100):
						color = '#fdae61';
						break;
					case (0 < d && d < 50):
						color = '#fee090';
						break;
					case (d == 0):
						color = '#BEBEBE';
						break;
					case (-50 < d && d < 0):
						color = '#abd9e9';
						break;
					case (-100 < d && d <= 50):
						color = '#74add1';
						break;
					case (-150 < d && d <= -100):
						color = '#4575b4';
						break;
					case (d <= -150):
						color = '#313695';
						break;
					default:
						color = '#BEBEBE';
						break;
				};

			}
			return color;
		}

		// Inspect the contents of the cache by printing all of the keys and values
		function print_cache_contents() {
			for (let i = 0; i < cache.length; i++) {
				console.log(cache[i].key);
				console.log(cache[i].value);
			}
		}

		// Add values to cache
		// Cache
		// Cache[0] = {key : key_phrase , value = {} }
		// where value is a dictionary of state and mort rate
		function add_to_cache(key_phrase, state, rate) {
			// Check if the key exists, in the cache
			// If the key does not exist, then add key
			if (key_exists(key_phrase) === false) {
				cache.push({
					key: key_phrase,
					value: {}
				});
			} else {
				// Else, append mort rate values to a dictionary portion of the key
				for (let i = 0; i < cache.length; i++) {
					if (key_phrase === cache[i].key) {
						let some_val = cache[i].value;
						some_val[state] = rate;
					};
				}
			}
		}

		function exists_in_cache(key_phrase, state) {
			// Check if the there is data in the cache for specific key phrase and state
			// return undefined if there is no entry
			let return_val = undefined;
			for (let i = 0; i < cache.length; i++) {
				if (key_phrase === cache[i].key) {
					return_val = cache[i].value[state];
					break;
				}
			}
			return return_val;
		}

		function key_exists(key_phrase) {
			// Check if key already exists in the cache
			let return_val = false;
			for (let i = 0; i < cache.length; i++) {
				if (key_phrase === cache[i].key) {
					return_val = true;
					break;
				}
			}
			return return_val;
		}

		function return_state_information(state_name, gender, race) {
			// return information about the state's heart disease mortality rate
			let mort_rate_val = 0;
			for (let i = 0; i < json_data.length; i++) {
				// make sure that correct state is being looked at, and race / gender are both reporting overall
				if (json_data[i][9] === state_name && json_data[i][11] === "State" && json_data[i][21] === gender && json_data[i][23] === race) {
					// GeographicalLevel = "State"
					mort_rate_val = json_data[i][15];
					break;
				}
			}
			// return the rounded value
			if (mort_rate_val < 1) {
				return_str = "Insufficient information";
			} else {
				return_str = Math.round(mort_rate_val) + "/100K people";
			}
			return [return_str, mort_rate_val];
		};

		function return_county_information(county, gender, race) {
			// return information about the state's heart disease mortality rate
			let mort_rate_val = 0;
			for (let i = 0; i < json_data.length; i++) {
				// make sure that correct state is being looked at, and race / gender are both reporting overall
				if (json_data[i][10].includes(county) && json_data[i][11] === "County" && json_data[i][21] === gender && json_data[i][23] === race) {
					// GeographicalLevel = "State"
					mort_rate_val = json_data[i][15];
					break;
				}
			}
			// return the rounded value
			if (mort_rate_val < 1) {
				return_str = "Insufficient information";
			} else {
				return_str = Math.round(mort_rate_val) + "/100K people";
			}
			return [return_str, mort_rate_val];
		}

		function return_state_information_difference(state_name) {
			// variables that will be used
			let mort_rate_difference = 0;
			// value_1` and value_2 are undefined at this point, will be used to know when to break out of loop
			let value_1;
			let value_2;
			for (let i = 0; i < json_data.length; i++) {
				// iterate through the json array and look for the specific state
				if (json_data[i][9] === state_name && json_data[i][11] === "State") {
					// once the state is correct, then look whether the gender and race for value 1 matches
					if (json_data[i][21] === g1 && json_data[i][23] === r1) {
						value_1 = json_data[i][15];
					}
					// once the state is correct, then look whether the gender and race for value 2 matches
					if (json_data[i][21] === g2 && json_data[i][23] === r2) {
						value_2 = json_data[i][15];
					}
					// once the two values are found, break out of the loop
					if (value_1 != undefined && value_2 != undefined) {
						break;
					}
				}
			}
			// check whether the values are null, if they are null, then it makes no sense to return a numeric difference
			if (value_1 === null || value_2 === null) {
				return_str = "Insufficient information";
			} else {
				denom = (parseFloat(value_1) + parseFloat(value_2)) / 2;
				num = parseFloat(value_1) - parseFloat(value_2);
				mort_rate_difference = Math.round((num / denom) * 100);
				return_str = mort_rate_difference + "%";
			}
			value_1 = value_1 == null ? "Insufficient information" : Math.round(value_1);
			value_2 = value_2 == null ? "Insufficient information" : Math.round(value_2);
			return [return_str, mort_rate_difference, value_1, value_2];
		};



		function return_county_information_difference(county) {
			// variables that will be used
			let mort_rate_difference = 0;
			// value_1` and value_2 are undefined at this point, will be used to know when to break out of loop
			let value_1;
			let value_2;
			for (let i = 0; i < json_data.length; i++) {
				// iterate through the json array and look for the specific county
				if (json_data[i][10].includes(county) && json_data[i][11] === "County") {
					// once the county is correct, then look whether the gender and race for value 1 matches
					if (json_data[i][21] === g1 && json_data[i][23] === r1) {
						value_1 = json_data[i][15];
					}
					// once the county is correct, then look whether the gender and race for value 2 matches
					if (json_data[i][21] === g2 && json_data[i][23] === r2) {
						value_2 = json_data[i][15];
					}
					// once the two values are found, break out of the loop
					if (value_1 != undefined && value_2 != undefined) {
						break;
					}
				}
			}
			// check whether the values are null, if they are null, then it makes no sense to return a numeric difference
			if (value_1 === null || value_2 === null) {
				return_str = "Insufficient information";
			} else {
				denom = (parseFloat(value_1) + parseFloat(value_2)) / 2;
				num = parseFloat(value_1) - parseFloat(value_2);
				mort_rate_difference = Math.round((num / denom) * 100);
				return_str = mort_rate_difference + "%";
			}
			value_1 = value_1 == null ? "Insufficient information" : Math.round(value_1);
			value_2 = value_2 == null ? "Insufficient information" : Math.round(value_2);
			return [return_str, mort_rate_difference, value_1, value_2];
		}

		// Set constraint bounds on the map so that users are not able to contonously scroll away
		var southWest = L.latLng(5, -175),
			northEast = L.latLng(80, -25),
			mybounds = L.latLngBounds(southWest, northEast);


		// setview 4 zoom and coordinates to middle of United States
		var map = L.map('map', {
			// wheel mouse zoom options to enable a smoooth zooming function
			zoomDelta: 0.25,
			zoomSnap: 0,
			wheelPxPerZoomLevel: 200
			// setView defines the center of the map
		}).setView([37.8, -98], current_zoom).setMaxBounds(mybounds);

		map.on('zoomend', function() {
			// based on the zoom of the map, determine which layer to show/remove
			// once the map is swtiched, update the global layer variable
			// update the informational section in top right
			if (map.getZoom() >= zoom_state_county_split && map_type_level != "county") {
				map.addLayer(geojson_county);
				map.removeLayer(geojson);
				map_type_level = "county";
				info.update();
			} else if (map.getZoom() <= zoom_state_county_split && map_type_level != "state") {
				map.addLayer(geojson);
				map.removeLayer(geojson_county);
				map_type_level = "state";
				info.update();
			}
		});

		L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
			// define the min Zoom so the user doesn't see a grey background
			maxZoom: 10,
			minZoom: 2,
			attribution: 'Map data: <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors ',
			id: 'mapbox.light'
		}).addTo(map);
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Info shows the state information to the user in the top right side of the map
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		var info = L.control();

		info.onAdd = function(map) {
			this._div = L.DomUtil.create('div', 'info');
			this.update();
			return this._div;
		};

		info.update = function(props) {
			// based on the current layer of the map, display different information in the top right
			if (map_type_level === "state") {
				// State level zoom
				if (race_gender_inspector === "Single") {
					// Single comparison mode
					this._div.innerHTML = '<h4>US Heart Disease Mortality rate</h4>' + (props ?
						'<b>' + 'State: ' + props.name + '</b><br />' + 'Density: ' + Math.round(props.density) + ' people / mi<sup>2</sup>' + '</b><br />' + 'Mortality rate: ' + return_state_information(props.abbreviation, gender, race)[0] :
						'Hover over a state to learn more!');
				} else {
					// Multiple comparison mode
					var temp = props ? return_state_information_difference(props.abbreviation) : null;
					this._div.innerHTML = '<h4>US Heart Disease Mortality rate</h4>' + (props ?
						'<b>' + 'State: ' + props.name + '</b><br />' + 'Density: ' + Math.round(props.density) + ' people / mi<sup>2</sup>' + '</b><br />' + 'Mortality rate percentage difference: ' + temp[0] + '<br />' + "Lookup criteria 1 : Gender(" + g1 +
						") Race(" + r1 +
						') mortality rate: ' + temp[2] + '<br />' + "Lookup criteria 2 : Gender(" + g2 + ") Race(" +
						r2 + ') mortality rate: ' + temp[3] :
						'Hover over a state to learn more!');
				}
				//document.getElementById("bottomofpage").innerHTML = 'Now hovered over: ' + (props ? '<b>' + props.name : 'Nowhere');
			} else {
				// County level zoom
				if (race_gender_inspector === "Single") {
					// Single comparison mode
					this._div.innerHTML = '<h4>US Heart Disease Mortality rate</h4>' + (props ?
						'<b>' + 'County: ' + props.NAME + '</b><br />' + 'Mortality rate: ' + return_county_information(props.NAME, gender, race)[0] :
						'Hover over a county to learn more!');
				} else {
					// Multiple comparison mode
					var temp = props ? return_county_information_difference(props.NAME) : null;
					this._div.innerHTML = '<h4>US Heart Disease Mortality rate</h4>' + (props ?
						'<b>' + 'County: ' + props.NAME + '</b><br />' + 'Mortality rate percentage difference: ' + temp[0] + '<br />' + "Lookup criteria 1 : Gender(" + g1 + ") Race(" + r1 +
						') mortality rate: ' + temp[2] + '<br />' + "Lookup criteria 2 : Gender(" + g2 + ") Race(" +
						r2 + ') mortality rate: ' + temp[3] :
						'Hover over a county to learn more!');
				}
				//document.getElementById("bottomofpage").innerHTML = 'Now hovered over: ' + (props ? '<b>' + props.NAME : 'Nowhere');
			}

		};
		info.addTo(map);
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Layer controls
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		function highlightFeature(e) {
			let layer = e.target;
			layer.setStyle({
				weight: 6,
				color: 'white',
				dashArray: '',
				fillOpacity: 0.7
			});

			if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
				layer.bringToFront();
			}
			info.update(layer.feature.properties);
		}

		function highlightCountyFeature(e) {
			let layer = e.target;
			layer.setStyle({
				weight: 6,
				color: 'white',
				dashArray: '',
				fillOpacity: 0.7
			});

			if (!L.Browser.ie && !L.Browser.opera && !L.Browser.edge) {
				layer.bringToFront();
			}
			info.update(layer.feature.properties);
		}

		function resetHighlight(e) {
			// reset the style after the mouse is moved to different state
			geojson.resetStyle(e.target);
			info.update();
		}

		function resetHighlightCounty(e) {
			// reset the style after the mouse is moved to different county
			geojson_county.resetStyle(e.target);
			info.update();
		}

		function zoomToFeature(e) {
			var layer = e.target;
			//map.fitBounds(e.target.getBounds());
		}

		// this is what happens when a state is clicked on
		function click_event_handler(e) {
			zoomToFeature(e);
			let layer = e.target;
			state = e.target.feature.properties.name;
			layer.setStyle({
				weight: 6,
				color: 'white',
				dashArray: '',
				fillOpacity: 0.7,
				fillColor: 'blue'
			});
			if (selection_count < selection_max) {
				if (!selection_list.includes(state)) {
					selection_count += 1;
					selection_list.push(state);
				} else {
					//alert(state + " is already in the list");
				}
			} else {
				selection_count = 1;
				selection_list.length = 0;
				selection_list.push(state);
			}
			// update the queue with the selection
			queue.update();
		}
		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		// only let users add states to the queue, not implemented on county level



		function onEachFeature(feature, layer) {
			// state level
			// this function determines what kind of event driven functionality exists for the layers
			layer.on({
				mouseover: highlightFeature,
				mouseout: resetHighlight,
				click: click_event_handler
			});
		}

		function onEachCountyFeature(feature, layer) {
			// county level
			// this function determines what kind of event driven functionality exists for the layers
			layer.on({
				mouseover: highlightCountyFeature,
				mouseout: resetHighlightCounty
			});
		}
		// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

		function sleep(ms) {
			// Way of letting time go by
			return new Promise(resolve => setTimeout(resolve, ms));
		}

		function style(feature) {
			let temp;
			if (race_gender_inspector === "Single") {
				// Single mode
				// Try to get a value from cache
				cache_lookup = exists_in_cache(race_gender_inspector + gender + race, feature.properties.abbreviation);
				if (cache_lookup === undefined) {
					//console.log("no cache");
					// if the value does not exist in the cache, get the value using search on the json data
					// append the result to the cache to be used later
					temp = return_state_information(feature.properties.abbreviation, gender, race)[1];
					add_to_cache(race_gender_inspector + gender + race, feature.properties.abbreviation, temp);
				} else {
					// get the value from the cache
					temp = cache_lookup;
					//console.log("returned from cache");
				}
				returncolor = return_Color(temp);
			} else {
				// Multiple mode
				// Try to get a value from cache
				cache_lookup = exists_in_cache(race_gender_inspector + g1 + r1 + g2 + r2, feature.properties.abbreviation);
				if (cache_lookup === undefined) {
					//console.log("no cache");
					// if the value does not exist in the cache, get the value using search on the json data
					// append the result to the cache to be used later
					temp = return_state_information_difference(feature.properties.abbreviation)[1];
					add_to_cache(race_gender_inspector + g1 + r1 + g2 + r2, feature.properties.abbreviation, temp);
				} else {
					temp = cache_lookup;
					// get the value from the cache
					//console.log("returned from cache");
				}
				returncolor = return_Color(temp);
			}
			return {
				weight: 3,
				opacity: 1,
				color: 'white',
				dashArray: '3',
				fillOpacity: 0.7,
				fillColor: returncolor
			};
		};

		function county_style(feature) {
			let temp;
			if (race_gender_inspector === "Single") {
				// Single mode
				// Try to get a value from cache
				cache_lookup = exists_in_cache(race_gender_inspector + gender + race, feature.properties.NAME);
				if (cache_lookup === undefined) {
					//console.log("no cache");
					// if the value does not exist in the cache, get the value using search on the json data
					// append the result to the cache to be used later
					temp = return_county_information(feature.properties.NAME, gender, race)[1];
					add_to_cache(race_gender_inspector + gender + race, feature.properties.NAME, temp);
				} else {
					// get the value from the cache
					temp = cache_lookup;
					//console.log("returned from cache");
				}
				returncolor = return_Color(temp);
			} else {
				// Multiple mode
				//temp = return_county_information_difference(feature.properties.NAME)[1];
				cache_lookup = exists_in_cache(race_gender_inspector + g1 + r1 + g2 + r2, feature.properties.NAME);
				if (cache_lookup === undefined) {
					//console.log("no cache");
					// if the value does not exist in the cache, get the value using search on the json data
					// append the result to the cache to be used later
					temp = return_county_information_difference(feature.properties.NAME)[1];
					add_to_cache(race_gender_inspector + g1 + r1 + g2 + r2, feature.properties.NAME, temp);
				} else {
					// get the value from the cache
					temp = cache_lookup;
					//console.log("returned from cache");
				}
				returncolor = return_Color(temp);
			}
			return {
				weight: 1,
				opacity: 1,
				color: 'white',
				dashArray: '3',
				fillOpacity: 0.5,
				fillColor: returncolor
			};
		};


		// for each feature in the geojson file, set the style and add it to the map
		geojson = L.geoJson(statesData, {
			style: style,
			onEachFeature: onEachFeature
		}).addTo(map);

		function load_county_data() {
			geojson_county = L.geoJson(countyData, {
				style: county_style,
				onEachFeature: onEachCountyFeature
			})
		}

		// load the data asynchrously
		setTimeout(load_county_data, 0);

		map.attributionControl.addAttribution('Heart disease data: <a target="_blank" href="https://catalog.data.gov/dataset/heart-disease-mortality-data-among-us-adults-35-by-state-territory-and-county-5fb7c">US Heart Disease Mortality Data</a>');

		//
		function reload_geojson() {
			geojson.eachLayer(async function(layer) {
				// get the current color of the respective layer
				var existing_color = layer.options.fillColor;
				var return_style;

				// get the new color based on the selection of the data
				return_style = style(layer.feature);
				//console.log('State: ' + layer.feature.properties.name + ' Existing fill color' + existing_color + ' - ' + return_style.fillColor);
				if (existing_color != return_style.fillColor) {
					// if the existing color does not match the new color that will be applied to the layer
					// signal to the user by changing the outline of the state in a blinking red and white fashion
					// sleep the change for 250 ms seconds so users will be able to register
					sleep_time = 150;
					number_of_blinks = 2;
					for (var i = 0; i < number_of_blinks; i++) {
						layer.setStyle({
							color: 'red'
						});
						await sleep(sleep_time);
						layer.setStyle({
							color: 'white'
						});
						i < number_of_blinks - 1 ? await sleep(sleep_time) : 'nothing';
					}
				};
				layer.setStyle(return_style);
			});
		}


		function reload_geojson_county() {
			geojson_county.eachLayer(async function(layer) {
				// get the current color of the respective layer
				// get the new color based on the selection of the data
				var existing_color = layer.options.fillColor;
				var return_style;
				// get the new color based on the selection of the data
				return_style = county_style(layer.feature);
				//console.log('State: ' + layer.feature.properties.name + ' Existing fill color' + existing_color + ' - ' + return_style.fillColor);
				if (existing_color != return_style.fillColor) {
					// if the existing color does not match the new color that will be applied to the layer
					// signal to the user by changing the outline of the state in a blinking red and white fashion
					// sleep the change for 250 ms seconds so users will be able to register
					sleep_time = 100;
					number_of_blinks = 2;
					for (var i = 0; i < number_of_blinks; i++) {
						layer.setStyle({
							color: 'red'
						});
						await sleep(sleep_time);
						layer.setStyle({
							color: 'white'
						});
						i < number_of_blinks - 1 ? await sleep(sleep_time) : 'nothing';
					}
				};
				layer.setStyle(return_style);
			});
		}
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Dropdown allows the user to make a selection to view the data by race or gender
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		var dropdown = L.control({
			position: 'bottomright'
		});

		dropdown.onAdd = function(e) {
			// add some values to the dropdown
			this._div = L.DomUtil.create('div', 'info');
			this._div.innerHTML = '<div style="text-align: center;"> <h4>Race / Gender interaction</h4>' +
				'<label onchange="radio_change()"><input type="radio" name="radio_comp_type" value="Single" checked><b>Single mode</b></label>' +
				'&nbsp;&nbsp;&nbsp;&nbsp;' +
				'<label onchange="radio_change()"><input type="radio" name="radio_comp_type" value="Multiple"><b>Multiple mode</b></label><br />' +

				'<div id = "single_selection_dropdown" style="text-align: left; padding-top: 5px; padding-bottom: 5px">' +
				'<div style="padding-left: 5px; padding-bottom: 5px">Gender - <select id="dd_gender_single1"><option>Overall</option><option>Female</option><option>Male</option></select></div>' +
				'<div style="padding-left: 5px; padding-bottom: 5px">Race - ' + '<select id="dd_race_single1"><option>Overall</option><option>White</option>' +
				'<option>Black</option><option>Asian and Pacific Islander</option><option>American Indian and Alaskan Native</option><option>Hispanic</option></select></div>' +
				'</div>' +

				'<div id = "multiple_selection_dropdown" style="display:none; text-align: left; padding-top: 5px; padding-bottom: 5px">' +
				'<div style="padding-left: 5px; padding-bottom: 5px">1st lookup criteria : <br /> Gender - <select id="dd_gender_multiple1"><option>Overall</option><option>Female</option><option>Male</option></select>' +
				'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' +
				'Race - <select id="dd_race_multiple1" ><option>Overall</option><option>White</option>' +
				'<option>Black</option><option>Asian and Pacific Islander</option><option>American Indian and Alaskan Native</option><option>Hispanic</option></select></div>' +

				'<div style="padding-left: 5px; padding-bottom: 5px">2nd lookup criteria : <br /> Gender - <select id="dd_gender_multiple2"><option>Overall</option><option>Female</option><option>Male</option></select>' +
				'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;' +
				'Race - <select id="dd_race_multiple2" ><option>Overall</option><option>White</option>' +
				'<option>Black</option><option>Asian and Pacific Islander</option><option>American Indian and Alaskan Native</option><option>Hispanic</option></select></div>' +
				'</div>' +

				'<div style="padding-bottom: 5px"><button class="btn" type="button" style="margin: auto" onclick="execute()">Update Map</button></div>' +
				'</div>'
			this._div.firstChild.onmousedown = this._div.firstChild.ondblclick = L.DomEvent.stopPropagation;
			return this._div;
		};


		function reload_based_on_priority() {
			if (map_type_level === "state") {
				// if the current zoom is state, reload state level geojson
				reload_geojson();
				reload_geojson_county();
			} else {
				// if the current zoom is county, reload state level geojson
				reload_geojson_county();
				reload_geojson();
			}
		}


		function execute() {
			if (race_gender_inspector === "Multiple") {
				g1 = document.getElementById("dd_gender_multiple1").value;
				g2 = document.getElementById("dd_gender_multiple2").value;
				r1 = document.getElementById("dd_race_multiple1").value;
				r2 = document.getElementById("dd_race_multiple2").value;
				drop_down_operator(true);
				reload_based_on_priority();
				setTimeout(function() {
					drop_down_operator(false);
				}, 900);
			} else {
				gender = document.getElementById("dd_gender_single1").value;
				race = document.getElementById("dd_race_single1").value;
				drop_down_operator(true);
				reload_based_on_priority();
				setTimeout(function() {
					drop_down_operator(false);
				}, 900);
			}
		}

		window.radio_change = function() {
			// Based on the radio button selection, display different set of divs to the user
			var curr_selection;
			var radio_choice = document.getElementsByName("radio_comp_type");
			for (var i = 0; i < radio_choice.length; i++) {
				if (radio_choice[i].checked) {
					curr_selection = radio_choice[i].value;
					break;
				}
			}
			race_gender_inspector = curr_selection;
			if (curr_selection === "Multiple") {
				document.getElementById("single_selection_dropdown").style.display = "none";
				document.getElementById("multiple_selection_dropdown").style.display = "block";
				legend.update();
			} else {
				document.getElementById("single_selection_dropdown").style.display = "block";
				document.getElementById("multiple_selection_dropdown").style.display = "none";
				legend.update();
			}
			setTimeout(reload_based_on_priority(), 0);
		}

		function drop_down_operator(bool_val) {
			// disable or enable dropdowns during transitions
			document.getElementById("dd_gender_single1").disabled = bool_val;
			document.getElementById("dd_race_single1").disabled = bool_val;
			document.getElementById("dd_gender_multiple1").disabled = bool_val;
			document.getElementById("dd_race_multiple1").disabled = bool_val;
			document.getElementById("dd_gender_multiple2").disabled = bool_val;
			document.getElementById("dd_race_multiple2").disabled = bool_val;
		};
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Queue displays the states that the user selects by clicking, currently there can be only two states in the queue at a time
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		var queue = L.control({
			position: 'topcenter'
		});

		queue.onAdd = function(e) {
			// Initially, make the div invisible to the user
			this._div = L.DomUtil.create('div', 'info');
			this._div.style.opacity = "0.0";
			return this._div;
		}

		queue.update = function(props) {
			// show the div if the user clicks any state and wants to add it to the queue
			// set the opacity of the div to 1.0
			this._div.style.opacity = "1.0";
			s = this._div.style;
			// update the contents of the div
			this._div.innerHTML = '<b>Items in the selection queue: ' + selection_list + '</b>';
			// provide smooth fadeout effect to the div
			fade_Out_Effect(this._div);
		}

		function fade_Out_Effect(div) {
			// decrease the opacity of the div by 0.01 every 20 ms, to provide a smooth fadeout effect
			var fadeEffect = setInterval(function() {
				if (!div.style.opacity) {
					div.style.opacity = 1;
				}
				if (div.style.opacity > 0) {
					div.style.opacity -= 0.01;
				} else {
					clearInterval(fadeEffect);
				}
			}, 20);
		}
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// Legend displays the color of the states that is corresponding to the mortaility rate
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		var legend = L.control({
			position: 'bottomleft'
		});

		legend.onAdd = function(map) {
			// create a div with legend styling
			this._div = L.DomUtil.create('div', 'info legend');
			this.update();
			return this._div;
		};

		legend.update = function() {
			if (race_gender_inspector === "Multiple") {
				resp_labels = [];
				partitions = [-150, -100, -50, 0, 50, 100, 150];
				resp_labels.push('<i style="background:' + return_Color(-151) + '"></i> ' + '-150% or more');
				for (var i = 0; i < partitions.length - 1; i++) {
					from = partitions[i];
					to = partitions[i + 1];
					if (i == 3) {
						resp_labels.push('<i style="background:' + return_Color(0) + '"></i> ' + '0% or no data');
					}
					// add to screen
					resp_labels.push(
						'<i style="background:' + return_Color(from + 1) + '"></i> ' +
						from + ' to ' + to + '%');
				}
				resp_labels.push('<i style="background:' + return_Color(151) + '"></i> ' + '150% or more');
				this._div.innerHTML = '<h4>Mortality rate % difference</h4>' + resp_labels.join('<br>');
			} else {
				resp_labels = [];
				partitions = [0, 50, 100, 150, 200, 250, 300, 350, 400, 450];
				for (var i = 0; i < partitions.length; i++) {
					// from is the first range and to is the second
					from = partitions[i];
					to = partitions[i + 1];
					// add to screen
					resp_labels.push(
						'<i style="background:' + return_Color(from + 1) + '"></i> ' +
						from + (to ? ' to ' + to + "" : '+'));
				}
				this._div.innerHTML = '<h4>Mortality rate</h4>' + resp_labels.join('<br>');
			}
		};
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		// add legend to map
		legend.addTo(map);
		// add dropdown to the map
		dropdown.addTo(map);
		// add queue to the map
		queue.addTo(map);
		// disable double click from zooming in the map
		map.doubleClickZoom.disable();
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		var body = document.getElementsByTagName('body')[0]
		var w = Math.round(body.clientWidth * 0.7);
		var h = Math.round(body.clientHeight * 0.3);

		function get_state_abbreviation(state_name) {
			for (let i = 0; i < json_data.length; i++) {
				if (json_data[i][10] === state_name && json_data[i][11] == "State") {
					return json_data[i][9];
				}
			}
			let str = "could not find state with name " + state_name;
			console.log(str);
			return str;
		};

		// a list that contains the name, state vs county type and mortality rate
		function get_county_data_of_state(state_abbreviation, gender, race) {
			var data = [];
			for (let i = 0; i < json_data.length; i++) {
				if (json_data[i][9] === state_abbreviation && json_data[i][21] === gender && json_data[i][23] === race) {
					data.push({
						county: json_data[i][10],
						type: json_data[i][11],
						mort_rate: json_data[i][15]
					});
				}
			}
			if (data.length === 0) {
				console.log('did not find any state/counties with matching state abbreviation ' + state_abbreviation);
			}
			return data;
		};

		function update_bars(county_data_of_state) {
			// update scales
			xScale.domain(d3.range(county_data_of_state.length));
			yScale.domain([0, d3.max(county_data_of_state, function(d) {
				return d.mort_rate;
			})]);
			colorScale.domain([0, d3.max(county_data_of_state, function(d) {
				return d.mort_rate;
			})]);

			//Update all rects
			var bars = svg.selectAll("rect").data(county_data_of_state);

			bars.enter().append("rect")
				.merge(bars)
				.attr("x", function(d, i) {
					return xScale(i);
				})
				.attr("y", function(d) {
					return h - yScale(d.mort_rate) + 5;
				})
				.attr("width", xScale.bandwidth())
				.attr("height", function(d) {
					return yScale(d.mort_rate);
				})
				.attr("fill", function(d) {
					if (d.type === "State") {
						return "green";
					}
					return "rgb(0, 0, " + Math.round(colorScale(d.mort_rate)) + ")";

				})
				.on("mouseover", function(d) {

					//Get this bar's x/y values, then augment for the tooltip
					var xPosition = parseFloat(d3.select(this).attr("x")) + xScale.bandwidth() / 2;
					//var yPosition = parseFloat(d3.select(this).attr("y")) / 2 + h / 2;

					//Update the tooltip position and value
					d3.select("#tooltip")
						.style("left", (w + 10) + "px")
						//.style("top", yPosition + "px")
						.select("#value")
						.text(d.mort_rate + "/100K");

					d3.select("#tooltip").select("#tooltipLabel").text(d.county)

					//Show the tooltip
					d3.select("#tooltip").classed("hidden", false);

				})
				.on("mouseout", function() {
					//Hide the tooltip
					d3.select("#tooltip").classed("hidden", true);

				});
			// remove old bars
			bars.exit().remove();
		};

		// should be sorted alphabetcally by default
		var sortOrder = false;

		// switch between sorting alphabetically and by mort rate
		function sort_bars() {
			sortOrder = !sortOrder;
			svg.selectAll("rect")
				.sort(function(a, b) {
					if (sortOrder) {
						return d3.descending(a.mort_rate, b.mort_rate);
					} else {
						return d3.ascending(a.county, b.county);
					}
				})
				.transition("sort_bars")
				.delay(300)
				.duration(1500)
				.attr("x", function(d, i) {
					return xScale(i);
				});
		};

		d3.select("#graphButtons")
			.select("#refreshGraph")
			.on("click", function() {

				if (selection_list.length > 0) {
					//New values for dataset
					var state_abbreviation = get_state_abbreviation(selection_list[selection_list.length - 1]);
					county_data_of_state = get_county_data_of_state(state_abbreviation, gender, race);
					update_bars(county_data_of_state);
					sortOrder = false;
				}
			});

		d3.select("#graphButtons")
			.select("#sortGraph")
			.on("click", function() {
				sort_bars();
			});


		var county_data_of_state = get_county_data_of_state("MA", gender, race);

		// returns an array of d3 scales to use with the county_data_of_state dataset
		var xScale = d3.scaleBand()
			.domain(d3.range(county_data_of_state.length))
			.rangeRound([0, w])
			.paddingInner(0.05);

		var yScale = d3.scaleLinear()
			.domain([0, d3.max(county_data_of_state, function(d) {
				return d.mort_rate;
			})])
			.range([15, h]);

		var colorScale = d3.scaleLinear()
			.domain([0, d3.max(county_data_of_state, function(d) {
				return d.mort_rate;
			})])
			.range([0, 255]);



		var svg = d3.select("body")
			.append("svg")
			.attr("width", w)
			.attr("height", h)
			.append("g");

		update_bars(county_data_of_state);


		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		var width = Math.round(body.clientWidth * 0.7);
		var height = Math.round(body.clientHeight * 0.3);

		// kludgy functions
		function get_state_data_overall(state_name) {
			var data = [];
			for (let j = 0; j < state_name.length; j++) {
				for (let i = 0; i < json_data.length; i++) {
					if (json_data[i][10] === state_name[j] && json_data[i][11] === "State" && json_data[i][21] === "Overall" && json_data[i][23] === "Overall") {
						data.push({
							state: json_data[i][10],
							mort_rate: json_data[i][15],
							gender: json_data[i][21],
							race: json_data[i][23]
						});
					}
				}
			}
			return data;
		};

		function get_state_data_gender(state_name) {
			var data = [];
			for (let j = 0; j < state_name.length; j++) {
				for (let i = 0; i < json_data.length; i++) {
					if (json_data[i][10] === state_name[j] && json_data[i][11] === "State" && json_data[i][21] != "Overall" && json_data[i][23] === "Overall") {
						data.push({
							state: json_data[i][10],
							mort_rate: json_data[i][15],
							gender: json_data[i][21],
							race: json_data[i][23]
						});
					}
				}
			}
			return data;
		};

		function get_state_data_race(state_name) {
			var data = [];
			for (let j = 0; j < state_name.length; j++) {
				for (let i = 0; i < json_data.length; i++) {
					if (json_data[i][10] === state_name[j] && json_data[i][11] === "State" && json_data[i][21] === "Overall" && json_data[i][23] != "Overall") {
						data.push({
							state: json_data[i][10],
							mort_rate: json_data[i][15],
							gender: json_data[i][21],
							race: json_data[i][23]
						});
					}
				}
			}
			return data;
		};

		function update_grouped_barchart(state_data, strata) {
			// adapted from https://stackoverflow.com/questions/45211408/making-a-grouped-bar-chart-using-d3-js
			var data = state_data;

			var margin = {
				top: 20,
				right: 20,
				bottom: 30,
				left: 40
			};

			//Create SVG element
			var svg = d3.select("body")
				.append("svg")
				.attr("width", w + margin.left + margin.right)
				.attr("height", h + margin.top + margin.bottom);



			var color = d3.scaleOrdinal(d3.schemeCategory10);

			var x = d3.scaleBand().rangeRound([0, w]).padding(0.1)
			var y = d3.scaleLinear().rangeRound([h, 0]);

			var g = svg.append("g")
				.attr("transform", "translate(" + margin.left + "," + margin.top + ")");;

			var ymaxdomain = d3.max(data, function(d) {
				return d.mort_rate;
			});

			x.domain(data.map(function(d) {
				return d.state
			}));

			y.domain([0, ymaxdomain]);

			var x1 = d3.scaleBand()
				.rangeRound([0, x.bandwidth()])
				.padding(0.05)
				.domain(data.map(function(d) {
					return d[strata];
				}));

			color.domain(data.map(function(d) {
				return d[strata];
			}));

			var groups = g.selectAll("rect")
				.data(data)
				.enter()
				.append("g")
				.attr("transform", function(d) {
					return "translate(" + x(d.state) + ",0)";
				})

			var bars = groups.selectAll("rect")
				.data(function(d) {
					return [d]
				})
				.enter()
				.append("rect")
				.attr("x", function(d, i) {
					return x1(d[strata])
				})
				.attr("y", function(d) {
					return y(d.mort_rate);
				})
				.attr("width", x1.bandwidth())
				.attr("height", function(d) {
					return h - y(d.mort_rate);
				})
				.attr("fill", function(d) {
					return color(d[strata])
				})

			g.append("g")
				.attr("class", "axis")
				.attr("transform", "translate(0," + h + ")")
				.call(d3.axisBottom(x));

			g.append("g")
				.attr("class", "axis")
				.call(d3.axisLeft(y).ticks(null, "s"))
				.append("text")
				.attr("x", 2)
				.attr("y", y(y.ticks().pop()) + 0.5)
				.attr("dy", "0.32em")
				.attr("fill", "#000")
				.attr("font-weight", "bold")
				.attr("text-anchor", "start")
				.text("mort_rate");

			// remove old bars
			bars.exit().remove();

		};

		d3.select("#groupedBarChartButtons")
			.select("#selectOverall")
			.on("click", function() {
				if (selection_list.length > 0) {
					//New values for dataset
					state_data = get_state_data_overall(selection_list);
					update_grouped_barchart(state_data, "");
				}
			});

		d3.select("#groupBarChartButtons")
			.select("#selectGender")
			.on("click", function() {
				if (selection_list.length > 0) {
					//New values for dataset
					state_data = get_state_data_gender(selection_list);
					update_grouped_barchart(state_data, "gender");
				}
			});

		d3.select("#groupedBarChartButtons")
			.select("#selectRace")
			.on("click", function() {
				if (selection_list.length > 0) {
					//New values for dataset
					state_data = get_state_data_race(selection_list);
					update_grouped_barchart(state_data, "race");
				}
			});

		var state_data = get_state_data_race("Massachusetts");

		// returns an array of d3 scales to use with the county_data_of_state dataset
		var xScale = d3.scaleBand()
			.domain(d3.range(state_data))
			.rangeRound([0, w])
			.paddingInner(0.05);

		var yScale = d3.scaleLinear()
			.domain([0, d3.max(state_data, function(d) {
				return d.mort_rate;
			})])
			.range([15, h]);

		var colorScale = d3.scaleLinear()
			.domain([0, d3.max(state_data, function(d) {
				return d.mort_rate;
			})])
			.range([0, 255]);



		var svg2 = d3.select("body")
			.append("svg")
			.attr("width", w)
			.attr("height", h)
			.append("g");

		//update_bars(state_data);
	</script>

</body>

</html>
